-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.3).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParFun
  ( happyError
  , myLexer
  , pProg
  , pExpr
  , pExpr1
  , pExpr2
  , pArg
  , pListArg
  , pStmt
  , pListStmt
  , pDecl
  , pListDecl
  , pMethods
  , pQType
  , pQPred
  , pTyDeRhs
  , pConAlt
  , pListConAlt
  , pCPred
  , pListCPred
  , pCType
  , pCType1
  , pCType2
  , pListCType
  ) where

import Prelude

import qualified AbsFun
import LexFun

}

%name pProg Prog
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
%name pArg Arg
%name pListArg ListArg
%name pStmt Stmt
%name pListStmt ListStmt
%name pDecl Decl
%name pListDecl ListDecl
%name pMethods Methods
%name pQType QType
%name pQPred QPred
%name pTyDeRhs TyDeRhs
%name pConAlt ConAlt
%name pListConAlt ListConAlt
%name pCPred CPred
%name pListCPred ListCPred
%name pCType CType
%name pCType1 CType1
%name pCType2 CType2
%name pListCType ListCType
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('        { PT _ (TS _ 1)      }
  ')'        { PT _ (TS _ 2)      }
  '*'        { PT _ (TS _ 3)      }
  ','        { PT _ (TS _ 4)      }
  '->'       { PT _ (TS _ 5)      }
  '.'        { PT _ (TS _ 6)      }
  ':'        { PT _ (TS _ 7)      }
  ';'        { PT _ (TS _ 8)      }
  '='        { PT _ (TS _ 9)      }
  '=>'       { PT _ (TS _ 10)     }
  '['        { PT _ (TS _ 11)     }
  '\\'       { PT _ (TS _ 12)     }
  ']'        { PT _ (TS _ 13)     }
  'class'    { PT _ (TS _ 14)     }
  'in'       { PT _ (TS _ 15)     }
  'instance' { PT _ (TS _ 16)     }
  'let'      { PT _ (TS _ 17)     }
  'mutual'   { PT _ (TS _ 18)     }
  'pragma'   { PT _ (TS _ 19)     }
  'type'     { PT _ (TS _ 20)     }
  '{'        { PT _ (TS _ 21)     }
  '|'        { PT _ (TS _ 22)     }
  '}'        { PT _ (TS _ 23)     }
  L_integ    { PT _ (TI $$)       }
  L_UIdent   { PT _ (T_UIdent $$) }
  L_LIdent   { PT _ (T_LIdent $$) }

%%

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

UIdent :: { AbsFun.UIdent }
UIdent  : L_UIdent { AbsFun.UIdent $1 }

LIdent :: { AbsFun.LIdent }
LIdent  : L_LIdent { AbsFun.LIdent $1 }

Prog :: { AbsFun.Prog }
Prog : ListDecl { AbsFun.Prog $1 }

Expr :: { AbsFun.Expr }
Expr
  : '{' ListStmt '}' { AbsFun.EBlock $2 }
  | Expr1 ':' CType { AbsFun.ETyped $1 $3 }
  | '\\' ListArg '->' Expr { AbsFun.ELam $2 $4 }
  | 'let' LIdent '=' Expr 'in' Expr { AbsFun.ELet $2 $4 $6 }
  | Expr1 { $1 }

Expr1 :: { AbsFun.Expr }
Expr1
  : Expr1 Expr2 { AbsFun.EApp $1 $2 }
  | Expr1 '.' Expr2 { AbsFun.EMet $1 $3 }
  | Expr1 '[' Expr ']' { AbsFun.EIdx $1 $3 }
  | '*' LIdent { AbsFun.EStar $2 }
  | Expr2 { $1 }

Expr2 :: { AbsFun.Expr }
Expr2
  : LIdent { AbsFun.EVar $1 }
  | UIdent { AbsFun.ECon $1 }
  | Integer { AbsFun.EInt $1 }
  | '(' Expr ')' { $2 }

Arg :: { AbsFun.Arg }
Arg
  : LIdent { AbsFun.UArg $1 }
  | '(' LIdent ':' CType ')' { AbsFun.TArg $2 $4 }

ListArg :: { [AbsFun.Arg] }
ListArg : {- empty -} { [] } | Arg ListArg { (:) $1 $2 }

Stmt :: { AbsFun.Stmt }
Stmt
  : Expr { AbsFun.SExpr $1 }
  | Expr '=' Expr { AbsFun.SAssign $1 $3 }
  | 'let' LIdent ':' CType { AbsFun.SAlloc $2 $4 }
  | 'let' LIdent '=' Expr { AbsFun.SInit $2 $4 }

ListStmt :: { [AbsFun.Stmt] }
ListStmt
  : {- empty -} { [] }
  | Stmt { (:[]) $1 }
  | Stmt ';' ListStmt { (:) $1 $3 }

Decl :: { AbsFun.Decl }
Decl
  : 'type' CType TyDeRhs { AbsFun.TypeDecl $2 $3 }
  | LIdent ':' QType { AbsFun.ValDecl $1 $3 }
  | LIdent ListArg '=' Expr { AbsFun.ValBind $1 $2 $4 }
  | 'mutual' '{' ListDecl '}' { AbsFun.Mutual $3 }
  | 'instance' QPred Methods { AbsFun.InstDecl $2 $3 }
  | 'class' CPred Methods { AbsFun.ClsDecl $2 $3 }
  | 'pragma' LIdent { AbsFun.Pragma $2 }

ListDecl :: { [AbsFun.Decl] }
ListDecl
  : {- empty -} { [] }
  | Decl { (:[]) $1 }
  | Decl ';' ListDecl { (:) $1 $3 }

Methods :: { AbsFun.Methods }
Methods
  : {- empty -} { AbsFun.NoMethods }
  | '{' ListDecl '}' { AbsFun.SomeMethods $2 }

QType :: { AbsFun.QType }
QType
  : CType { AbsFun.T0Qual $1 }
  | CPred '=>' CType { AbsFun.T1Qual $1 $3 }
  | '(' ListCPred ')' '=>' CType { AbsFun.TNQual $2 $5 }

QPred :: { AbsFun.QPred }
QPred
  : CPred { AbsFun.I0Qual $1 }
  | CPred '=>' CPred { AbsFun.I1Qual $1 $3 }
  | '(' ListCPred ')' '=>' CPred { AbsFun.INQual $2 $5 }

TyDeRhs :: { AbsFun.TyDeRhs }
TyDeRhs
  : {- empty -} { AbsFun.EmptyTyDeRhs }
  | '=' ListConAlt { AbsFun.ConAlts $2 }

ConAlt :: { AbsFun.ConAlt }
ConAlt
  : UIdent { AbsFun.ConAlt0 $1 }
  | UIdent '[' ListCType ']' { AbsFun.ConAltN $1 $3 }

ListConAlt :: { [AbsFun.ConAlt] }
ListConAlt
  : {- empty -} { [] }
  | ConAlt { (:[]) $1 }
  | ConAlt '|' ListConAlt { (:) $1 $3 }

CPred :: { AbsFun.CPred }
CPred
  : CType ':' UIdent { AbsFun.PSingle $1 $3 }
  | CType ':' UIdent '[' ListCType ']' { AbsFun.PMulti $1 $3 $5 }

ListCPred :: { [AbsFun.CPred] }
ListCPred
  : {- empty -} { [] }
  | CPred { (:[]) $1 }
  | CPred ',' ListCPred { (:) $1 $3 }

CType :: { AbsFun.CType }
CType : CType1 '->' CType { AbsFun.CTArr $1 $3 } | CType1 { $1 }

CType1 :: { AbsFun.CType }
CType1
  : UIdent '[' ListCType ']' { AbsFun.CTCon $1 $3 } | CType2 { $1 }

CType2 :: { AbsFun.CType }
CType2
  : UIdent { AbsFun.CTCon0 $1 }
  | LIdent { AbsFun.CTVar $1 }
  | '(' CType ')' { $2 }

ListCType :: { [AbsFun.CType] }
ListCType
  : {- empty -} { [] }
  | CType { (:[]) $1 }
  | CType ',' ListCType { (:) $1 $3 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

